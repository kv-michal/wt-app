<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="manifest" href="/wt-app/manifest.webmanifest">
    <meta name="theme-color" content="#667eea">

    <!-- iOS Home Screen (iOS uses these, not the manifest icons) -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="apple-touch-icon" href="/wt-app/icons/icon-192.png">
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>White Noise Player</title>
    <!-- Preload hints for local MP3 files -->
    <link rel="preload" as="audio" href="./sounds/vacuum-cleaner.mp3">
    <link rel="preload" as="audio" href="./sounds/train.mp3">
    <link rel="preload" as="audio" href="./sounds/city-streets.mp3">
    <link rel="preload" as="audio" href="./sounds/tent-rain.mp3">
    <link rel="preload" as="audio" href="./sounds/lake-rain.mp3">
    <link rel="preload" as="audio" href="./sounds/waterfall.mp3">
    <link rel="preload" as="audio" href="./sounds/mall-chatter.mp3">
    <link rel="preload" as="audio" href="./sounds/ocean-waves.mp3">
    <link rel="preload" as="audio" href="./sounds/campfire.mp3">
    <link rel="preload" as="audio" href="./sounds/warehouse-fans.mp3">
    <link rel="preload" as="audio" href="./sounds/autumn-wind.mp3">
    <link rel="preload" as="audio" href="./sounds/pink-noise.mp3">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 18px;
            font-size: 2.2rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .role-switch {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }

        .role-pill {
            display: inline-flex;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 999px;
            overflow: hidden;
        }

        .role-btn {
            background: rgba(255, 255, 255, 0.12);
            border: none;
            color: #fff;
            padding: 10px 16px;
            cursor: pointer;
            font-weight: 600;
            transition: all .2s ease;
        }

        .role-btn.inactive {
            opacity: 0.5;
        }

        .role-btn.active {
            background: rgba(255, 255, 255, 0.55);
            text-shadow: 1px 1px 10px #000000b8;
        }

        .role-hint {
            opacity: .85;
            font-size: .95rem;
        }

        .loading-indicator {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .loading-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .loading-progress {
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            width: 0%;
            transition: width 0.3s ease;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .sound-control {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            transition: all .3s ease;
        }

        .sound-control:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .sound-control.loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .sound-control.loading::after {
            content: 'Loading...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .sound-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .sound-title {
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sound-icon {
            font-size: 1.5rem;
        }

        .toggle-btn {
            width: 60px;
            height: 30px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: all .3s ease;
        }

        .toggle-btn.active {
            background: #4CAF50;
        }

        .toggle-btn::after {
            content: '';
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: all .3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .toggle-btn.active::after {
            transform: translateX(30px);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-slider {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .master-controls {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
        }

        .master-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            margin: 0 10px 10px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all .3s ease;
        }

        .master-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .master-btn:disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .schedule-row {
            margin-top: 12px;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .schedule-row input {
            width: 120px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            outline: none;
        }

        .status {
            margin-top: 10px;
            font-size: .9rem;
            opacity: .9;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1
            }
            50% {
                opacity: .7
            }
        }

        .playing {
            animation: pulse 2s infinite;
        }

        .disabled-ui {
            pointer-events: none;
            opacity: .6;
            filter: grayscale(0.1);
        }

        /* Fade banner */
        .fade-banner {
            position: sticky;
            top: 0;
            margin: 0 auto 0;
            max-width: 720px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.6);
            background: rgba(0, 0, 0, 0.25);
            padding: 10px 12px;
            z-index: 1000;
        }

        .fade-row {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .fade-chip {
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.25);
        }

        .fade-time {
            opacity: .95;
            font-variant-numeric: tabular-nums;
        }

        .fade-bar-wrap {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .fade-bar {
            height: 100%;
            width: 0%;
            background: rgba(255, 255, 255, 0.85);
            transition: width .1s linear;
        }

        .qr-container {
            text-align: center;
            margin-top: 24px;
        }

        .qr-container img {
            background: white;
            padding: 10px;
            border-radius: 12px;
        }

        .qr-url {
            margin-top: 8px;
            font-size: .85rem;
            opacity: .9;
            word-break: break-all;
        }

        .audio-info {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }
    </style>
</head>
<body>
<div class="container">
    <!-- Fade banner (appears during slow fade for both roles) -->
    <div id="fadeBanner" class="fade-banner" hidden>
        <div class="fade-row" style="margin-bottom:8px;">
            <span class="fade-chip">Fading out…</span>
            <span id="fadeTime" class="fade-time">60s left</span>
        </div>
        <div class="fade-bar-wrap">
            <div id="fadeBar" class="fade-bar"></div>
        </div>
    </div>

    <h1>🎵 White Noise Player</h1>

    <!-- Loading indicator -->
    <div id="loadingIndicator" class="loading-indicator">
        <div>Loading audio files...</div>
        <div id="loadingText">Initializing Web Audio API...</div>
        <div class="loading-bar">
            <div id="loadingProgress" class="loading-progress"></div>
        </div>
    </div>

    <!-- Role switch -->
    <div class="role-switch">
        <span class="role-hint" id="roleHint">Select a role</span>
        <div class="role-pill">
            <button id="btn-dudo" class="role-btn">DUDO</button>
            <button id="btn-papa" class="role-btn">PAPA</button>
        </div>
    </div>

    <div class="controls disabled-ui" id="soundControls"></div>

    <div class="master-controls disabled-ui" id="masterControls">
        <button class="master-btn" id="btn-slowlyStopAll">Slowly Stop All</button>
        <button class="master-btn" id="btn-stopAll">Stop All</button>
        <button class="master-btn" id="btn-toggleMaster">Mute/Unmute</button>
        <button class="master-btn" id="btn-resetAll">Reset</button>

        <div class="schedule-row">
            <label for="stopInMinutes">Stop in</label>
            <input id="stopInMinutes" type="number" min="0" step="0.1" value="90"/>
            <span>minutes</span>
            <button class="master-btn" id="btn-scheduleStop">Set Timer</button>
        </div>

        <div class="status" id="status">Initializing...</div>
        <div class="audio-info" id="audioInfo">Web Audio API: Initializing...</div>

        <!-- QR Code at the bottom -->
        <div class="qr-container">
            <p>📱 Scan to open this page:</p>
            <img id="qrCode" alt="QR Code of this page" width="220" height="220"/>
            <div id="qrUrl" class="qr-url"></div>
        </div>
    </div>
</div>

<script>
    // UUID
    function uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }

    const urlParams = new URLSearchParams(window.location.search);
    const remoteClientId = urlParams.get("client");
    const userId = remoteClientId ?? uuidv4();

    // ========= Relay Setup (using ntfy.sh) =========
    const NTFY_TOPIC = `white-noise-dudo-papa-${userId}`;
    const RELAY_POST_URL = `https://ntfy.sh/${NTFY_TOPIC}`;
    const RELAY_SSE_URL = `https://ntfy.sh/${NTFY_TOPIC}/sse`;

    const CLIENT_ID = (() => Math.random().toString(36).slice(2))();
    let CURRENT_ROLE = null; // 'DUDO' | 'PAPA'
    let sse = null;

    function debounce(fn, wait = 100) {
        let t;
        return (...args) => {
            clearTimeout(t);
            t = setTimeout(() => fn(...args), wait);
        };
    }

    const debouncedVolumeSenders = new Map();

    function getDebouncedVolumeSender(soundId) {
        if (!debouncedVolumeSenders.has(soundId)) {
            debouncedVolumeSenders.set(
                soundId,
                debounce((vol) => sendRelayEvent('setVolume', {soundId, volume: vol}), 2000)
            );
        }
        return debouncedVolumeSenders.get(soundId);
    }

    function setRole(role) {
        CURRENT_ROLE = role;
        document.getElementById('btn-dudo').classList.toggle('active', role === 'DUDO');
        document.getElementById('btn-dudo').classList.toggle('inactive', role !== 'DUDO');
        document.getElementById('btn-papa').classList.toggle('active', role === 'PAPA');
        document.getElementById('btn-papa').classList.toggle('inactive', role !== 'PAPA');
        const master = document.getElementById('masterControls');
        const controls = document.getElementById('soundControls');

        if (role === 'DUDO') {
            master.classList.remove('disabled-ui');
            controls.classList.remove('disabled-ui');
            startPolling();
        } else {
            master.classList.remove('disabled-ui');
            controls.classList.remove('disabled-ui');
            stopPolling();
        }
    }

    async function sendRelayEvent(eventName, payload = {}) {
        if (CURRENT_ROLE !== 'PAPA') return;
        const body = JSON.stringify({
            clientId: CLIENT_ID,
            role: CURRENT_ROLE,
            ts: Date.now(),
            event: {name: eventName, ...payload}
        });
        try {
            await fetch(RELAY_POST_URL, {method: 'POST', body}); // no headers ⇒ avoid CORS preflight
        } catch (e) {
            console.warn('Relay send failed:', e);
        }
    }

    function startPolling() {
        sse = new EventSource(RELAY_SSE_URL);
        sse.onmessage = (e) => {
            try {
                const msg = JSON.parse(e.data);
                if (msg.event !== 'message') return;
                const evt = JSON.parse(msg.message || '{}');
                if (evt?.clientId === CLIENT_ID) return;
                applyRemoteEvent(evt);
            } catch {
            }
        };
    }

    function stopPolling() {
        if (sse) {
            sse.close();
            sse = null;
        }
    }

    function applyRemoteEvent(wrapper) {
        if (!wrapper || !wrapper.event) return;
        const {name, soundId, seconds, minutes, volume} = wrapper.event;
        switch (name) {
            case 'toggle':
                player.toggle(soundId);
                break;
            case 'setVolume':
                if (typeof volume === 'number') {
                    const slider = document.getElementById(`volume-${soundId}`);
                    if (slider) slider.value = String(volume);
                    player.setVolume(soundId, volume);
                }
                break;
            case 'stopAll':
                player.stopAll();
                break;
            case 'toggleMaster':
                player.toggleMasterVolume();
                break;
            case 'slowlyStopAll':
                player.slowlyStopAll(seconds ?? 60); // DUDO will show banner + fade
                break;
            case 'resetAll':
                player.resetAll();
                break;
            case 'scheduleStop':
                player.scheduleStopInMinutes(minutes ?? 90);
                break;
        }
    }

    // ========= Web Audio API Player =========
    class WebAudioWhiteNoisePlayer {
        constructor() {
            this.audioContext = null;
            this.masterGain = null;
            this.sounds = {};
            this.masterLevel = 0.5;
            this.isMuted = false;
            this.previousMasterLevel = 0.5;
            this.stopTimerId = null;
            this.stopEta = null;
            this.fadeIntervalId = null;

            // Fade UI state
            this.fadeStartTs = null;
            this.fadeEndTs = null;
            this.fadeRafId = null;

            this.soundDefinitions = [
                {
                    id: 'vacuum',
                    name: 'Vacuum Cleaner',
                    icon: '🧹',
                    url: '/sounds/vacuum-cleaner.mp3'
                },
                {
                    id: 'train',
                    name: 'Train',
                    icon: '🚆',
                    url: '/sounds/train.mp3'
                },
                {
                    id: 'city',
                    name: 'City',
                    icon: '🏙️',
                    url: '/sounds/city-streets.mp3'
                },
                {
                    id: 'tentrain',
                    name: 'Tent Rain',
                    icon: '⛺',
                    url: '/sounds/tent-rain.mp3'
                },
                {
                    id: 'rain',
                    name: 'Rain',
                    icon: '🌧️',
                    url: '/sounds/lake-rain.mp3'
                },
                {
                    id: 'waterfall',
                    name: 'Waterfall',
                    icon: '🏞️',
                    url: '/sounds/waterfall.mp3'
                },
                {
                    id: 'people',
                    name: 'People',
                    icon: '🗣️',
                    url: '/sounds/mall-chatter.mp3'
                },
                {
                    id: 'ocean',
                    name: 'Ocean',
                    icon: '🌊',
                    url: '/sounds/ocean-waves.mp3'
                },
                {
                    id: 'fire',
                    name: 'Firecamp',
                    icon: '🔥',
                    url: '/sounds/campfire.mp3'
                },
                {
                    id: 'fan',
                    name: 'Fan',
                    icon: '🌀',
                    url: '/sounds/warehouse-fans.mp3'
                },
                {
                    id: 'wind',
                    name: 'Wind',
                    icon: '💨',
                    url: '/sounds/autumn-wind.mp3'
                },
                {
                    id: 'pink',
                    name: 'Pink Noise',
                    icon: '🌸',
                    url: '/sounds/pink-noise.mp3'
                },
            ];

            this.loadedCount = 0;
            this.totalSounds = this.soundDefinitions.length;
            this.isReady = false;

            this.init();
        }

        async init() {
            try {
                // Initialize Web Audio API
                this.updateAudioInfo('Initializing Web Audio API...');
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.audioContext.createGain();
                this.masterGain.connect(this.audioContext.destination);
                this.masterGain.gain.value = this.masterLevel;

                this.updateAudioInfo(`Web Audio API initialized (${this.audioContext.sampleRate}Hz)`);

                // Load all audio files
                await this.loadAllSounds();

                // Create UI controls
                this.createSoundControls();
                this.wireMasterButtons();

                // Hide loading indicator
                document.getElementById('loadingIndicator').style.display = 'none';

                this.isReady = true;
                this.updateStatus();
                this.updateAudioInfo(`Ready - ${this.totalSounds} sounds loaded`);

            } catch (error) {
                console.error('Failed to initialize Web Audio API:', error);
                this.updateStatus('Failed to initialize audio - please refresh the page');
                this.updateAudioInfo('Error: ' + error.message);
            }
        }

        updateLoadingProgress(loaded, total, currentFile = '') {
            const percentage = Math.round((loaded / total) * 100);
            document.getElementById('loadingProgress').style.width = `${percentage}%`;
            document.getElementById('loadingText').textContent =
                currentFile ? `Loading: ${currentFile} (${loaded}/${total})` : `${loaded}/${total} files loaded`;
        }

        updateAudioInfo(text) {
            const el = document.getElementById('audioInfo');
            if (el) el.textContent = text;
        }

        async loadAllSounds() {
            this.updateLoadingProgress(0, this.totalSounds, 'Starting...');

            const loadPromises = this.soundDefinitions.map(async (def, index) => {
                try {
                    this.updateLoadingProgress(this.loadedCount, this.totalSounds, def.name);

                    const response = await fetch(def.url);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);

                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);

                    // Create sound object with Web Audio nodes
                    this.sounds[def.id] = {
                        buffer: audioBuffer,
                        source: null,
                        gainNode: null,
                        gain: 0.5,
                        playing: false,
                        definition: def
                    };

                    this.loadedCount++;
                    this.updateLoadingProgress(this.loadedCount, this.totalSounds, def.name);

                } catch (error) {
                    console.error(`Failed to load ${def.name}:`, error);
                    this.updateLoadingProgress(this.loadedCount, this.totalSounds, `Error loading ${def.name}`);

                    // Create placeholder for failed loads
                    this.sounds[def.id] = {
                        buffer: null,
                        source: null,
                        gainNode: null,
                        gain: 0.5,
                        playing: false,
                        definition: def,
                        error: error.message
                    };
                }
            });

            await Promise.all(loadPromises);
        }

        createSoundControls() {
            const container = document.getElementById('soundControls');
            this.soundDefinitions.forEach(sound => {
                const soundData = this.sounds[sound.id];
                const hasError = soundData && soundData.error;

                const controlDiv = document.createElement('div');
                controlDiv.className = `sound-control ${hasError ? 'loading' : ''}`;
                controlDiv.innerHTML = `
          <div class="sound-header">
            <div class="sound-title">
              <span class="sound-icon">${sound.icon}</span>${sound.name}
              ${hasError ? ' ❌' : ''}
            </div>
            <button class="toggle-btn" id="toggle-${sound.id}" ${hasError ? 'disabled' : ''}></button>
          </div>
          <div class="volume-control">
            <span>🔊</span>
            <input type="range" class="volume-slider" id="volume-${sound.id}" min="0" max="100" value="50" ${hasError ? 'disabled' : ''}>
            <span id="vol-display-${sound.id}">50%</span>
          </div>
          ${hasError ? `<div class="audio-info">Error: ${soundData.error}</div>` : ''}`;
                container.appendChild(controlDiv);

                if (!hasError) {
                    const btn = controlDiv.querySelector(`#toggle-${sound.id}`);
                    btn.addEventListener('click', async () => {
                        if (CURRENT_ROLE === 'PAPA') {
                            sendRelayEvent('toggle', {soundId: sound.id});
                            // reflect toggle in PAPA UI immediately
                            const btn = document.getElementById(`toggle-${sound.id}`);
                            btn?.classList.toggle('active');
                            btn?.closest('.sound-control')?.classList.toggle('playing');
                        } else {
                            await this.toggle(sound.id);
                        }
                    });

                    const slider = controlDiv.querySelector(`#volume-${sound.id}`);
                    slider.addEventListener('input', (e) => {
                        const vol = Number(e.target.value);
                        this.setVolume(sound.id, vol);
                        if (CURRENT_ROLE === 'PAPA') {
                            getDebouncedVolumeSender(sound.id)(vol);
                        }
                    });
                }
            });
        }

        wireMasterButtons() {
            document.getElementById('btn-slowlyStopAll').addEventListener('click', () => {
                if (CURRENT_ROLE === 'PAPA') {
                    // show visual feedback locally AND send command to DUDO
                    this.beginFadeUI(60);
                    sendRelayEvent('slowlyStopAll', {seconds: 60});
                } else {
                    this.slowlyStopAll(60);
                }
            });

            document.getElementById('btn-stopAll').addEventListener('click', () => {
                if (CURRENT_ROLE === 'PAPA') sendRelayEvent('stopAll');
                else this.stopAll();
            });

            document.getElementById('btn-toggleMaster').addEventListener('click', () => {
                if (CURRENT_ROLE === 'PAPA') sendRelayEvent('toggleMaster');
                else this.toggleMasterVolume();
            });

            document.getElementById('btn-resetAll').addEventListener('click', () => {
                if (CURRENT_ROLE === 'PAPA') sendRelayEvent('resetAll');
                else this.resetAll();
            });

            document.getElementById('btn-scheduleStop').addEventListener('click', () => {
                const val = Number(document.getElementById('stopInMinutes').value || 90);
                if (CURRENT_ROLE === 'PAPA') sendRelayEvent('scheduleStop', {minutes: val});
                else this.scheduleStopInMinutes(val);
            });

            document.getElementById('btn-dudo').addEventListener('click', () => setRole('DUDO'));
            document.getElementById('btn-papa').addEventListener('click', () => setRole('PAPA'));
        }

        async toggle(soundId) {
            if (!this.isReady) return;

            const entry = this.sounds[soundId];
            if (!entry || entry.error) return;

            if (entry.playing) {
                this.stop(soundId);
            } else {
                await this.start(soundId);
            }
            this.updateStatus();
        }

        async start(soundId) {
            const entry = this.sounds[soundId];
            if (!entry || entry.error || !entry.buffer) return;

            try {
                // Resume audio context if suspended (required for autoplay policy)
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                // Stop existing source if any
                if (entry.source) {
                    entry.source.stop();
                    entry.source.disconnect();
                }

                // Create new source and gain node
                entry.source = this.audioContext.createBufferSource();
                entry.gainNode = this.audioContext.createGain();

                // Set up the audio graph: source -> gainNode -> masterGain -> destination
                entry.source.buffer = entry.buffer;
                entry.source.loop = true;
                entry.source.connect(entry.gainNode);
                entry.gainNode.connect(this.masterGain);

                // Set volume
                const volumeSlider = document.getElementById(`volume-${soundId}`);
                if (volumeSlider) {
                    entry.gain = Number(volumeSlider.value) / 100;
                }
                entry.gainNode.gain.value = entry.gain;

                // Start playing
                entry.source.start();
                entry.playing = true;

                // Update UI
                const btn = document.getElementById(`toggle-${soundId}`);
                btn?.classList.add('active');
                btn?.closest('.sound-control')?.classList.add('playing');

            } catch (error) {
                console.error(`Failed to start ${soundId}:`, error);
                this.setStatus(`Error playing ${soundId}: ${error.message}`);
            }
        }

        stop(soundId) {
            const entry = this.sounds[soundId];
            if (!entry || !entry.playing) return;

            try {
                if (entry.source) {
                    entry.source.stop();
                    entry.source.disconnect();
                    entry.source = null;
                }
                if (entry.gainNode) {
                    entry.gainNode.disconnect();
                    entry.gainNode = null;
                }
            } catch (error) {
                console.warn(`Error stopping ${soundId}:`, error);
            }

            entry.playing = false;

            // Update UI
            const btn = document.getElementById(`toggle-${soundId}`);
            btn?.classList.remove('active');
            btn?.closest('.sound-control')?.classList.remove('playing');
        }

        stopAll() {
            Object.keys(this.sounds).forEach(id => this.stop(id));
            this.endFadeUI(); // hide banner if visible
            this.updateStatus();
        }

        setVolume(soundId, volume) {
            const vol0to1 = Number(volume) / 100;
            const entry = this.sounds[soundId];
            const slider = document.getElementById(`volume-${soundId}`);
            const label = document.getElementById(`vol-display-${soundId}`);

            if (slider && slider.value !== String(volume)) slider.value = String(volume);
            if (label) label.textContent = `${Math.round(Number(volume))}%`;

            if (entry) {
                entry.gain = vol0to1;
                if (entry.gainNode) {
                    entry.gainNode.gain.value = vol0to1;
                }
            }
        }

        toggleMasterVolume() {
            if (this.isMuted) {
                this.isMuted = false;
                this.masterLevel = this.previousMasterLevel || 0.5;
            } else {
                this.previousMasterLevel = this.masterLevel;
                this.isMuted = true;
                this.masterLevel = 0;
            }

            if (this.masterGain) {
                this.masterGain.gain.value = this.masterLevel;
            }

            this.updateStatus();
        }

        // ---------- Fade UI helpers ----------
        beginFadeUI(seconds) {
            const banner = document.getElementById('fadeBanner');
            const bar = document.getElementById('fadeBar');
            const timeEl = document.getElementById('fadeTime');

            const durMs = Math.max(100, Number(seconds) * 1000 || 60000);
            this.fadeStartTs = Date.now();
            this.fadeEndTs = this.fadeStartTs + durMs;

            banner.hidden = false;

            const tick = () => {
                const now = Date.now();
                const total = this.fadeEndTs - this.fadeStartTs;
                const remain = Math.max(0, this.fadeEndTs - now);
                const elapsed = Math.min(total, now - this.fadeStartTs);
                const pct = total > 0 ? (elapsed / total) : 1;

                if (timeEl) timeEl.textContent = `${Math.ceil(remain / 1000)}s left`;
                if (bar) bar.style.width = `${Math.round(pct * 100)}%`;

                if (remain > 0) {
                    this.fadeRafId = requestAnimationFrame(tick);
                } else {
                    // keep bar filled until the audio fade function hides banner
                    this.fadeRafId = null;
                }
            };
            if (this.fadeRafId) cancelAnimationFrame(this.fadeRafId);
            tick();
        }

        endFadeUI() {
            const banner = document.getElementById('fadeBanner');
            const bar = document.getElementById('fadeBar');
            const timeEl = document.getElementById('fadeTime');
            if (this.fadeRafId) {
                cancelAnimationFrame(this.fadeRafId);
                this.fadeRafId = null;
            }
            if (bar) bar.style.width = '0%';
            if (timeEl) timeEl.textContent = '';
            if (banner) banner.hidden = true;
            this.fadeStartTs = null;
            this.fadeEndTs = null;
        }

        // ------------------------------------

        slowlyStopAll(seconds = 60) {
            const durMs = Math.max(100, Number(seconds) * 1000 || 60000);

            // Start/refresh the visual banner for BOTH roles
            this.beginFadeUI(seconds);

            if (this.fadeIntervalId) {
                clearInterval(this.fadeIntervalId);
                this.fadeIntervalId = null;
            }

            const startLevel = this.isMuted ? 0 : this.masterLevel;
            const startTs = Date.now();

            this.setStatus(`Fading out over ${Math.round(durMs / 1000)}s…`);

            this.fadeIntervalId = setInterval(() => {
                const elapsed = Date.now() - startTs;
                const t = Math.min(1, elapsed / durMs);
                const newLevel = startLevel * (1 - t);

                if (this.masterGain) {
                    this.masterGain.gain.value = newLevel;
                }

                if (t >= 1) {
                    clearInterval(this.fadeIntervalId);
                    this.fadeIntervalId = null;
                    this.stopAll();
                    // restore previous master for next play
                    this.isMuted = false;
                    this.masterLevel = this.previousMasterLevel || 0.5;
                    if (this.masterGain) {
                        this.masterGain.gain.value = this.masterLevel;
                    }
                    this.endFadeUI(); // ensure banner hides
                    this.updateStatus();
                }
            }, 50);
        }

        resetAll() {
            if (this.stopTimerId) {
                clearTimeout(this.stopTimerId);
                this.stopTimerId = null;
                this.stopEta = null;
            }
            if (this.fadeIntervalId) {
                clearInterval(this.fadeIntervalId);
                this.fadeIntervalId = null;
            }
            this.endFadeUI();

            this.stopAll();

            this.soundDefinitions.forEach(s => {
                const slider = document.getElementById(`volume-${s.id}`);
                const label = document.getElementById(`vol-display-${s.id}`);
                if (slider) slider.value = 50;
                if (label) label.textContent = '50%';
                const btn = document.getElementById(`toggle-${s.id}`);
                btn?.classList.remove('active');
                btn?.closest('.sound-control')?.classList.remove('playing');

                // Reset sound data
                const entry = this.sounds[s.id];
                if (entry && !entry.error) {
                    entry.gain = 0.5;
                }
            });

            this.isMuted = false;
            this.masterLevel = 0.5;
            this.previousMasterLevel = 0.5;

            if (this.masterGain) {
                this.masterGain.gain.value = this.masterLevel;
            }

            const inp = document.getElementById('stopInMinutes');
            if (inp) inp.value = 90;

            this.setStatus('Reset to initial state');
        }

        scheduleStopInMinutes(minutes) {
            if (this.stopTimerId) {
                clearTimeout(this.stopTimerId);
                this.stopTimerId = null;
                this.stopEta = null;
            }

            const m = Math.max(0, Number(minutes) || 0);
            if (m === 0) {
                this.slowlyStopAll(5);
                return;
            }
            if (m <= 1) {
                this.slowlyStopAll(m * 60);
                return;
            }

            const delayMs = (m - 1) * 60 * 1000;
            const eta = new Date(Date.now() + delayMs + 60 * 1000);
            this.stopEta = eta;

            this.stopTimerId = setTimeout(() => {
                // When the last minute starts, show the banner and fade
                this.slowlyStopAll(60);
                this.stopTimerId = null;
                this.stopEta = null;
            }, delayMs);

            const hh = eta.getHours().toString().padStart(2, '0');
            const mm = eta.getMinutes().toString().padStart(2, '0');
            this.setStatus(`Scheduled stop at ${hh}:${mm} (last minute will fade out)`);
        }

        setStatus(text) {
            const status = document.getElementById('status');
            if (status) status.textContent = text;
        }

        updateStatus() {
            if (!this.isReady) {
                this.setStatus('Initializing...');
                return;
            }

            const playingSounds = Object.values(this.sounds).filter(s => s.playing && !s.error);
            const n = playingSounds.length;
            const status = document.getElementById('status');

            if (this.stopEta) {
                const hh = this.stopEta.getHours().toString().padStart(2, '0');
                const mm = this.stopEta.getMinutes().toString().padStart(2, '0');
                status.textContent = `${n === 0 ? 'Ready' : `${n} sound${n > 1 ? 's' : ''} playing`} • Scheduled stop at ${hh}:${mm}`;
                return;
            }
            if (n === 0) status.textContent = 'Ready to play';
            else if (this.isMuted) status.textContent = `${n} sound${n > 1 ? 's' : ''} playing (Muted)`;
            else status.textContent = `${n} sound${n > 1 ? 's' : ''} currently playing`;
        }
    }

    // Initialize
    let player;
    window.addEventListener('load', () => {
        player = new WebAudioWhiteNoisePlayer();
    });

    // Expose (handy for console)
    window.setRole = setRole;

    // ----- QR code: simple <img> endpoint (no CORS needed) -----
    const url = `${window.location.href}?client=${userId}`;
    const qrImg = document.getElementById('qrCode');
    const qrUrlText = document.getElementById('qrUrl');
    const QR_ENDPOINT = 'https://api.qrserver.com/v1/create-qr-code/';
    const params = new URLSearchParams({size: '220x220', margin: '0', data: url});
    qrImg.src = `${QR_ENDPOINT}?${params.toString()}`;
    qrUrlText.textContent = url;
</script>
</body>
</html>

